package my;

import java.lang.reflect.Array;


public final class TestNames {
    private static boolean first = true;

    private static void showClass(Class<?> c) {
        String formatString = "%-15s  %-15s\t  %-18s\t  %s\n";

        if (first) {
            first = false;
            System.out.format(formatString,
                "SimpleName", "CanonicalName", "Name", "toString");
        }

        System.out.format(formatString,
            c.getSimpleName(), c.getCanonicalName(), c.getName(), c.toString());
    }

    private static void showLamda(Runnable r) {
        showClass(r.getClass());
        // Obtains an array class of a lambda base type
        showClass(Array.newInstance(r.getClass(), 1).getClass());
    }

    public static class NestedClass {}

    public static class NestedClass2 {}

    public class InnerClass {}

    public class InnerClass2 {}

    {
        class LocalClass3 {}
    }

    public static void main(String[] args) {
        class LocalClass {}
        class LocalClass2 {}

        {
            class LocalClass3 {}
        }

        System.out.println("" + Object.class.isAssignableFrom(Integer[].class));

        showClass(void.class);
        showClass(int.class);
        showClass(String.class);
        showClass(Runnable.class);
        showClass(SomeEnum.class);
        showClass(SomeAnnotation.class);
        showClass(boolean[].class);
        showClass(int[].class);
        showClass(String[].class);
        showClass(NestedClass.class);
        showClass(InnerClass.class);
        showClass(LocalClass.class);
        showClass(LocalClass[].class);

        Object anonymous = new java.io.Serializable() {};
        showClass(anonymous.getClass());
        anonymous = new java.io.Serializable() {};
        // Obtains an array class of an anonymous base type.
        showClass(Array.newInstance(anonymous.getClass(), 1).getClass());
        showLamda(() -> {});
    }
}

enum SomeEnum {
    BLUE, YELLOW, RED;
}

@interface SomeAnnotation {}


/*
So, here are the rules. First, lets start with primitive types and void:

    If the class object represents a primitive type or void, all the four
    methods simply returns its name.

Now the rules for the getName() method:

    Every non-lambda and non-array class or interface (i.e, top-level, nested,
    inner, local and anonymous) has a name (which is returned by getName())
    that is the package name followed by a dot (if there is a package),
    followed by the name of its class-file as generated by the compiler
    (whithout the suffix .class). If there is no package, it is simply the
    name of the class-file. If the class is an inner, nested, local or
    anonymous class, the compiler should generate at least one $ in its
    class-file name. Note that for anonymous classes, the class name would
    end with a dollar-sign followed by a number.

    Lambda class names are generally unpredictable, and you shouldn't care
    about they anyway. Exactly, their name is the name of the enclosing class,
    followed by $$Lambda$, followed by a number, followed by a slash, followed
    by another number.

    The class descriptor of the primitives are Z for boolean, B for byte, S for
    short, C for char, I for int, J for long, F for float and D for double. For
    non-array classes and interfaces the class descriptor is L followed by what
    is given by getName() followed by ;. For array classes, the class descriptor
    is [ followed by the class descriptor of the component type (which may be
    itself another array class).

    For array classes, the getName() method returns its class descriptor. This
    rule seems to fail only for array classes whose the component type is a
    lambda (which possibly is a bug), but hopefully this should not matter
    anyway because there is no point even on the existence of array classes whose
    component type is a lambda.

Now, the toString() method:

    If the class instance represents an interface (or an annotation, which is a
    special type of interface), the toString() returns "interface " + getName().
    If it is a primitive, it returns simply getName(). If it is something else
    (a class type, even if it is a pretty weird one), it returns "class " + getName().

The getCanonicalName() method:

    For top-level classes and interfaces, the getCanonicalName() method returns
    just what the getName() method returns.

    The getCanonicalName() method returns null for anonymous or local classes and
    for array classes of those.

    For inner and nested classes and interfaces, the getCanonicalName() method
    returns what the getName() method would replacing the compiler-introduced
    dollar-signs by dots.

    For array classes, the getCanonicalName() method returns null if the canonical
    name of the component type is null. Otherwise, it returns the canonical name
    of the component type followed by [].

The getSimpleName() method:

    For top-level, nested, inner and local classes, the getSimpleName() returns
    the name of the class as written in the source file.

    For anonymous classes the getSimpleName() returns an empty String.

    For lambda classes the getSimpleName() just returns what the getName() would
    return without the package name. This do not makes much sense and looks like
    a bug for me, but there is no point in calling getSimpleName() on a lambda
    class to start with.

    For array classes the getSimpleName() method returns the simple name of the
    component class followed by []. This have the funny/weird side-effect that
    array classes whose component type is an anonymous class have just [] as
    their simple names.
 */
